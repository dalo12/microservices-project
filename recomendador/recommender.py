# -*- coding: utf-8 -*-
"""[TADW 2025] - Sistemas de recomendación

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ieC9aMhiK0u0VfG8S2e63Q1dut-cdYEi

"""

## Importando librerías y cargando los datos

import pandas as pd
import numpy as np
from collections import Counter
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity

from pymongo import MongoClient
from pymongo.errors import ConnectionFailure
import json
from bson import json_util
import os

import warnings
warnings.filterwarnings('ignore')

DATABASE_CONN_STRING = os.environ.get("DATABASE_CONN_STRING") or "mongodb://admin:12345@localhost:27017/sample_mflix?authSource=admin"

movies = {}

# MongoDB connection setup
def connect_to_mongodb():
    """Connect to MongoDB and return database client."""
    try:
        client = MongoClient(DATABASE_CONN_STRING)
        # Check connection
        client.admin.command('ping')
        print("Successfully connected to MongoDB!")
        return client
    except ConnectionFailure as e:
        print(f"Could not connect to MongoDB: {e}")
        return None

def load_mflix_data(client, database_name="sample_mflix"):
    """Load movies data from MFlix database."""
    db = client[database_name]
    movies_collection = db.movies
    
    # Query movies with necessary fields
    movies_data = list(movies_collection.find(
        {
            "title": {"$exists": True},
            "imdb.rating": {"$exists": True, "$ne": ""},
            "imdb.votes": {"$exists": True, "$ne": ""},
            "genres": {"$exists": True, "$ne": []},
            "cast": {"$exists": True, "$ne": []}
        },
        {
            "_id": 0,
            "title": 1,
            "year": 1,
            "genres": 1,
            "cast": 1,
            "directors": 1,
            "writers": 1,
            "plot": 1,
            "fullplot": 1,
            "imdb.rating": 1,
            "imdb.votes": 1,
            "tomatoes.viewer.rating": 1,
            "tomatoes.viewer.numReviews": 1,
            "awards": 1,
            "languages": 1,
            "countries": 1,
            "type": 1,
            "runtime": 1
        }
    ))
    #.limit(5000))  # Limit to 5000 movies for performance
    
    # Convert to DataFrame
    movies_df = pd.DataFrame(movies_data)
    
    return movies_df

def clean_mflix_data(df):
    """Clean and prepare MFlix movies data."""
    # Create clean copies of the original data
    df_clean = df.copy()
    
    # Flatten nested imdb fields
    df_clean['imdb_rating'] = df_clean['imdb'].apply(lambda x: x.get('rating') if isinstance(x, dict) else None)
    df_clean['imdb_votes'] = df_clean['imdb'].apply(lambda x: x.get('votes') if isinstance(x, dict) else None)

    # Handle ratings and votes
    df_clean['average_rating'] = pd.to_numeric(df_clean['imdb_rating'], errors='coerce')
    df_clean['ratings_count'] = pd.to_numeric(df_clean['imdb_votes'], errors='coerce')
    


    # Handle tomatoes ratings if available
    if 'tomatoes.viewer.rating' in df_clean.columns:
        df_clean['tomato_rating'] = pd.to_numeric(df_clean['tomatoes.viewer.rating'], errors='coerce')
        df_clean['tomato_count'] = pd.to_numeric(df_clean['tomatoes.viewer.numReviews'], errors='coerce')
    
    # Fill NaN ratings with 0
    df_clean['average_rating'] = df_clean['average_rating'].fillna(0)
    df_clean['ratings_count'] = df_clean['ratings_count'].fillna(0)
    
    # Handle genres (convert list to string)
    df_clean['genres_str'] = df_clean['genres'].apply(
        lambda x: ', '.join(x) if isinstance(x, list) else ''
    )
    
    # Handle cast (convert list to string)
    df_clean['cast_str'] = df_clean['cast'].apply(
        lambda x: ', '.join(x[:5]) if isinstance(x, list) and len(x) > 0 else ''  # Limit to first 5 cast members
    )
    
    # Handle directors
    """ df_clean['directors_str'] = df_clean['directors'].apply(
        lambda x: ', '.join(x) if isinstance(x, list) else str(x) if pd.notna(x) else ''
    ) """

    # Directors transformation
    df_clean['directors_clean'] = df_clean['directors'].apply(
        lambda x: ', '.join(str.lower(i.replace(" ", "")) for i in x) if isinstance(x, list) else ''
    )
    
    # Clean titles
    df_clean['title_clean'] = df_clean['title'].astype(str)
    
    # Remove movies with no ratings
    df_clean = df_clean[df_clean['ratings_count'] > 0]
    
    # Remove movies with no genres
    df_clean = df_clean[df_clean['genres_str'].str.strip() != '']
    
    return df_clean

def build_chart(data, genre, percentile=0.85):
    # Chequeamos que la película pertenezca al género recibido, ignorando valores nulos
    qualified = data[data['genres_str'].notna() & data['genres_str'].str.lower().str.contains(genre.lower())]

    # Verificamos que haya peliculas calificadas
    if qualified.empty:
        return "No hay películas calificadas en este género."

    v = qualified['ratings_count']
    m = qualified['ratings_count'].quantile(percentile)
    R = qualified['average_rating']
    C = qualified['average_rating'].mean()
    qualified['weighted_rating'] = (R * v + C * m) / (v + m)

    qualified.sort_values('weighted_rating', ascending=False, inplace=True)
    return qualified

def create_indexes():
    return pd.Series(movies.index, index=movies['title'])

def get_recommendations(title, n=10, self_exclude = True):
    try:
        indices = create_indexes()
        # Se intenta obtener el índice del título dado
        idx = indices[title]
    except KeyError:
        # Si el título no existe, se procede a encontrar el índice de la película más similar
        sim_scores = list(enumerate(cosine_sim))
        idx = max(sim_scores, key=lambda x: max(x[1]))[0]  # Índice de la película más similar

    # Se buscan las puntuaciones de similitud para la pelícual dada
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    if self_exclude :
      sim_scores = sim_scores[1:n+1]
    else :
      sim_scores = sim_scores[0:n+1]
    movie_indices = [i[0] for i in sim_scores]
    scores = [i[1] for i in sim_scores]  # Se extraen los sim_scores

    # Se crea un DataFrame que integre las películas recomendadas y sus sim_scores
    recommended_movies = movies.iloc[movie_indices].copy()
    recommended_movies['sim_score'] = scores

    return recommended_movies

def get_recommendations_hybrid(title, n=10, self_exclude=True):
    try:
        # Se intenta obtener el índice del título dado
        indices = create_indexes()
        idx = indices[title]
    except KeyError:
        # Si el título no existe, se procede a encontrar el índice de la película más similar
        sim_scores = list(enumerate(cosine_sim))
        idx = max(sim_scores, key=lambda x: max(x[1]))[0]  # Índice de la película más similar

    # Se buscan las puntuaciones de similitud para la película dada
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    if self_exclude:
        sim_scores = sim_scores[1:n+1]
    else:
        sim_scores = sim_scores[0:n+1]

    movie_indices = [i[0] for i in sim_scores]
    cosine_similarities = [i[1] for i in sim_scores]

    # Se calcula la nueva métrica
    rating = movies['average_rating'].iloc[movie_indices].values
    hybrid_scores = [cosine_sim * rating for cosine_sim, rating in zip(cosine_similarities, rating)]
    scores = [i[1] for i in sim_scores]

    # Se crea un DataFrame que integre las películas recomendadas y sus scores híbridos
    recommended_movies = movies.iloc[movie_indices].copy()
    recommended_movies['sim_score'] = scores
    recommended_movies['hybrid_score'] = hybrid_scores

    # Se ordenaa por la nueva métrica en orden descendente
    recommended_movies.sort_values('hybrid_score', ascending=False, inplace=True)

    return recommended_movies

if __name__ == "__main__":
    # Connect to MongoDB
    client = connect_to_mongodb()
    if client:
        # Load data from MongoDB
        movies_df = load_mflix_data(client)
        print(f"Loaded {len(movies_df)} movies from MongoDB")
        print("\nSample of raw movies data:")
        print(movies_df[['title', 'year', 'genres']].head())
        
        # Clean and transform data
        movies = clean_mflix_data(movies_df)

        # Display sample data
        print("\nSample of movies data:")
        print(movies[['title', 'year', 'genres_str', 'average_rating', 'ratings_count']].head())

        # Tranformación de autores
        #movies['directors_clean'] = movies['directors'].apply(lambda x: ', '.join(str.lower(i.replace(" ", "")) for i in x.split(', ')))

        print(movies['directors_clean'].head())

        print("Percentil 95 =", round(movies['ratings_count'].quantile(0.95)))

        v = movies['ratings_count']
        m = movies['ratings_count'].quantile(0.95)
        R = movies['average_rating']
        C = movies['average_rating'].mean()
        W = (R*v + C*m) / (v + m)

        movies['weighted_rating'] = W

        qualified = movies.sort_values('weighted_rating', ascending=False).head(250)

        print(qualified[['title', 'directors', 'average_rating', 'ratings_count', 'weighted_rating', 'genres']].head(15))

        # En primer lugar, separamos los géneros en listas
        genres_list = movies['genres'].str.split(', ')

        # Reemplazamos valores nulos en genres_list con listas vacías
        genres_list = genres_list.apply(lambda x: x if isinstance(x, list) else [])

        # Creamos una lista única de todos los géneros
        all_genres = sum(genres_list, [])

        # Contamos la frecuencia de cada género
        genre_counts = pd.DataFrame(Counter(all_genres).items(), columns=['genre', 'count']).sort_values(by='count', ascending=False)

        # Filtramos los 15 géneros más frecuentes
        top_genres = genre_counts.head(15)

        # Sumamos el resto de los géneros en una única opción ("Others")
        others_count = genre_counts['count'][15:].sum()

        # Creamos un nuevo DataFrame para "Others"
        others_df = pd.DataFrame({'genre': ['Others'], 'count': [others_count]})

        # Concatenamos los dos DataFrames
        final_genres = pd.concat([top_genres, others_df], ignore_index=True)

        print("Percentil 85 =", round(movies['ratings_count'].quantile(0.85)))

        genre = 'Biography'
        print(build_chart(movies, genre).head(15)[['title_clean', 'directors_clean', 'genres_str', 'average_rating', 'ratings_count', 'weighted_rating']])

        movies['directors_clean'].head()

        # Combinamos en un mismo string los títulos, autores y géneros
        movies['soup'] = movies.apply(lambda x: ' '.join([str(x['title_clean']), str(x['directors_clean'] or ''), str(x['genres_str'] or '')]), axis=1)

        # Exploremos el resultado
        print(movies.soup.head())

        count = CountVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0.0, stop_words='english')
        count_matrix = count.fit_transform(movies['soup'])
        cosine_sim = cosine_similarity(count_matrix, count_matrix)

        """Preparemos ahora un mapeo para obtener fácilmente el el índice de una película a partir de su título:"""

        titles = movies['title']

        print(get_recommendations("The Godfather"))